Clase 2

¿Que puede ir dentro de la cabecera del documento <head>? (2 hs a )

Etiquetas de Encabezado (2:13 hs a 2:18 hs)

 
**********************************************************


Clase 3

Etiquetas semanticas

Son etiquetas que dividen la estructura de la pagina web en partes.

Elementos dentro del body (27 min a 35 min)
	header
		Titulos, barras de navegacion
	main
		Tiene el contenido principal
	footer
		Es el pie de pagina

Correcto uso de Encabezados (1:10 hs a 1:13 hs)

Uso de Rutas Relativas y Absolutas (2:03 hs)
	Atributo href=""
	Atributo target="_blank"
		No lo utilizo con rutas RELATIVAS
		La usamos con ABSOLUTAS
	Atributo target="_parent"
	Atributo target="_self"
	Atributo target="_top"
		Lo ultimos 3 se comportan igual.

	Atributo title=""
		Atributo de accesibilidad para personas con discapacidad visual.
	
	

************************************************************

Clase 4

Arquitectura y estructura de nuestra pagina web
Entendiendo las partes principales
Estructuramos lo que esta adentro del body


Ruteo interno en Rutas Relativas (14 min )

Busquedas optimizadas de Google (20 min)
	¿Por que es importante utilizar etiquetas semanticas?
		Por que google rankea de esa manera las paginas para sus busquedas.

Etiquetas <section> y <article> (26 min a 35 min)
	Estan dentro de la etiqueta <main>
	section es un bloque en el cual yo divido la informacion en diferente grupos tematicos.
	articles son los temas principales de algun area, son las divisiones de la informacion dentro del section.


Rutas Relativas usando id (38 min)

Ejemplo Proyecto Final (1:19 hs 1:30 hs)

Agregar IMAGENES con etiqueta <figure> y <figcaption>(1:34 hs)
	<img src="" alt="">
		Atributo alt (texto alternativo) es obligatorio para mejorar la accesibilidad.

	<figcaption> una pequeña nota/comentario de la imagen que estamos viendo.

Manejo con carpeta ASSETS (1:53 hs)
	Los assets son el lugar donde guardo todos esos que nosostros en algun momento queremos mostrar.

Arquitectura
	la forma en que estructuro los directorios.


************************************************************

Clase 5

Repaso clase anterior (0 min a 20 min)

Listas Ordenadas (23 min & 51 min)

Etiquetas de BLOQUE y LINEA (32 min)

Etiqueta <address>
	Va en footer
	
	Bloque: ocupan el 100% del ancho del dispositivo en donde se esta mostrando la aplicacion.

Etiqueta <iframe> 
	Incrusto una ventana de otra pagina en nuestro sitio
	Lo usamos para mostrar mapas
	Esta gernealmente en el footer

Agrega mapa

Agregar video 

Agregar audio

Etiqueta correo electronico y telefono (2 hs)
	Se usa en el Footer generalmente
	Se usa con un ancla con atributo href="mailto:hola@udesa"
	Para telefono se usa ancla con atributo href="tel:"



************************************************************

Clase 6

Realización de examen Alumni (2:30 min)

Estilos con CSS (13 min)

	Tenemos 3 formas de trabajar con css
		Estilos en linea
		Estilos en bloque (23 min)
		Estilos en el head (34 min)
		Etilos Externos (38 min)

	
	Configuracion de usuario en Git bash (1:20 hs)
			Para que vscode reconozca quien soy.
	Un poco de Chrome Dev Tools (21 min)

	COMO CONFIGURAR PERFIL EN VSCODE PARA SIEMPRE TENER TUS EXTENSIONES (1:37 HS)
	Git lens en VSCODE (1:38 hs)
	Github pull Request
	Iniciar sesion en VSCODE


************************************************************

Clase 7


¿QUE ES EL ROOT ? (12 min)
	Es la raiz principal del proyecto o de la aplicacion.

Diferencias entre <strong> y <b> Accesibilidad (16 min)

Repositorio LOCAL GIT (40 min)

Repositorio REMOTO GitHUb (1:39 hs)

************************************************************

Clase 8

Continuamos con Git (24 min)

	git status
	git no guarda directorios vacios
	git remote -v
	git log


ID (1:07 hs)


CLASES (1:08:30 hs a 1:34 hs)


Concepto Caja (2:05 hs)
	Margin, border, padding 


************************************************************

Clase 9


Paleta de colores Adobe (10 min)

Formas de representar un color (26 min)
	Por rgb
	Por nombre
	Por Hexadecimal

Selectores anidados o Padres a hijos (45 min)

Tipografias (54 min)
	font-size (16px por default)
	font-family
		¿que pasa si el usuario no tiene estas tipografias en su computadora?
	Para no tener que depender del font-family podes:

	1° puedo descargar una tipografia y agregarla a mi proyecto (USO DE TIPOGRAFIA LOCAL)
	2° lINKEAR o importarla ()

1) como hago para configurar nuestra tipografia con el codigo descargado
	
	a)@font-face{ (configuro donde esta la fuente que descargue)
	b) creo la regla y le asigno le nombre de la fuente


2a) linkear de Google fonts en el html y en el css lo llamamos

2b) Importarlo directamente desde el css (1:49 hs)
	a) poner en el css el @import url('')

Se puede usar mezclado 1 y 2.


GIT - continuacion (2:00 hs)

.gitignore
	
	index.html
	.css
	/css o css/
	*.pdf -> no me subas todos los pdf


************************************************************

Clase 10



Para que sirven los DIV's ? (17 min)


Repaso Font-family descarga o linkeo (30 min)
	google Fonts


Concepto de Caja (54 min)

	Margin (1:00 hs) - separacion entre etiquetas
	Border (1:08 hs) - 
	Padding (1:16 hs) - es el relleno interno



Live Share (1:35 hs)
	Compartir Visual Studio Code (pair programming)
	Herramienta para trabajar en EQUIPO

	requerimientos:
	Estar logueado con usuario en github



Git - .gikeep (2:05 hs)


************************************************************

Clase 11


GIT (25:30 min)

	Agregar COLABORADORES dentro de nuestro Proyecto
		Esto lo hace el que tiene el repo principal:
		Settings -> Collaborators -> Add people

	git pull - busca su hay cambios en el repo remoto y si hay los descarga y me los guarda. Si el pull encuentra diferencias te deja decidir si hay cambios sobre una misma.
 
	A veces aunque hiciste git pull al inicio tenes que hacer de nuevo antes de git push luego de varias horas de codeo. 	

	git clone - es crear una copia exacta del repo remoto con logs y todo


Es recomendable trabajar con imagenes PNG y SVG (1:28 hs)
	Son los mas flexibles y ligeros

Ancla con imagen adentro (1:47 hs)

Background image (1:49 hs)

	
************************************************************

Clase 12


Sketch Web / wireframe (17 min)

	Sketch Es un pequeño diseño a mano alzada donde le muestro al cliente o el me pide como seria la pagina (es un borrador)

	
	Wireframe es algo digital


Herramientas de Diseño (24 min)

	Figma

	Balsamiq (25:30 min)

	invisionapp (28 min)

	Canva (29 min)


Examen 2 Alumni (36 min)


Subir ICONO a mi pestaña (47:30 min)

	Convertir de PNG a ICO en cualquier app online



	text-decoration: none

	Las imagenes vectoriales se acomodan mas facilmtente a los contenedores, no necesito usar muchas media querys



Formularios (1:13 hs)

	Atributo action - representa el archivo o el lugar a donde yo voy a estar enviando todos los datos que cargue dentro del formulario (para enviarlo en algun momento a una base de datos) 	

	Atribuo method - es la forma en la que se envia la informacion

	Metodo post - envio de datos a traves del http con navegadores o servidores. Va oculto a la vista del usuario.

	Metodo get - no es recomendado utilizarlo porque va a la vista del usuario.

	label (ELEMENTO DE LINEA) - etiqueta informativa sobre el campo a llenar por el usuario

		Atributo For va vinculada al id del input

	input (ELEMENTO DE LINEA) - es el unico lugar donde el usuario puede introducir dato en una pagina web.

		type="text"

		type="email"

		type="number"

	
	Atributo required - hago que un campo sea obligatorio de llenar.

	Atributo placeholder="juan perez" - es un ejemplo de un valor escrito dentro del atributo para el cliente.


	Button

		type="submit" - para que el boton haga algo le tengo que pedir que haga algo.

		type="reset" - borra los datos ingresados en los inputs que estan el formulario.

	
	Revision de los metodos HTTP (1:30 hs)


	Elemento select con atributo id vinculado con for de label (1:59 hs)

		elemento optgroup donde voy cargando los datos que quiero que se muestren



************************************************************

Clase 13


git clone (28 min)

GithubPages (41:30 min)

Es solo para Frontend

	Voy a Settings 
	Voy a Pages
	Deploy from a branch (seleccionamos la rama en la que hacemos deploy)
	en Branch elijo Master y doy a Save


000WebHost (1:20 hs - a:54 hs)

	Es un servidor profesional (parecido a Github pages) donde nosotros podemos ingresar y podemos manejar y administrar nuestro servidor.

	Solo sirve para Frontend para nosotros, porque maneja backend con PHP y nosotros vamos a utilizar backend con NODE JS para lo cual vamos a utilizar servidores AWS, Railway o algun otro que sirva con Node JS.

	000Webhost te da un hosting gratuito para un dominio por un año.


	iniciar sesion
	Elegir "Subir sitio"
	En "public_html" subo mis proyectos web
	Nunca borrar archivos en carpetas "public_html" y "tmp"

	Con este tema cerramos el modulo 4



	Intro JS (1:57 hs)

	// - Comentarios de una sola linea en JS 

	/* */ - Comentarios de varias lineas en JS

	Variables (2:03 hs)

		Es un espacio de memoria para almacenar datos.

		Como inicializamos una variable en JS:

			Con palabras reservadas:

				"var" nombre 



************************************************************

Clase 14

 
Continuacion JS

		Uso consola de Chrome (17 min)
			Variables

		Formas INCORRECTAS de nombrar una variable (30 min)

		VAR, LET y CONST (38:30 min)

		var se creo con JS

		let y const se creo con una actualizacion de JS

		CONST - se escriben en mayuscula (por ej. DNI)

		CONST - cuando la creamos tenemos que definirla  (const DNI = 92925103)

		VAR y LET - NO es obligatorio asignarles un valor(o inicializar) cuando la declaras.

		
		Tipos de Errores: 
			
					de Sintaxis 	
					de Compilacion ( salta cuando se ejecuta el codigo)
					Logicos (multiplicar un string con un numero)
						Los errores de compilacion/ejecucion y logicos se ven cuando se ejecuta el software.


		Concatenacion de Variables (nombre + apellido)


		Funciones por Defecto/nativas:

					console.log() - Imprime en la consola

		
		Isamiento de la variable (1:05 hs)

			Pasa con VAR
					 
					
	Vinculacion de archivo JS con HTML (1:11 hs)

	funcion alert()

	Operadores Matematicos (1:41:30 hs)



************************************************************

Clase 15


Instalación Node JS (10 min a 46 min)



Que es NPM (49 min)

	Es el Administrador de paquetes de Node.
	
	instala, actualiza o elimina herramientas que son as librerías al núcleo de NODE JS


	Que son las LIBRERIAS ? -> Son código JavaScript que tienen una tarea especifica que realizar.



Nodemon (56 min)

	Como instalo Nodemon: npm install -g nodemon

	Mantiene la ejecución del código abierta.

	Corto Nodemon:
		cierro la terminal
		Ctrl + C

	Nodemon solo funciona con codigo JS nativo, por ejemplo la funcion alert, prompt no funcionan porque es una funcion de ventana.

	SIEMPRE VA FUNCIONAR NODEMON CUANDO NO TENGAMOS QUE UTILIZAR FUNCIONES QUE NECESITAN VENTANAS DE NAVEGADOR.



Error Terminal PowerShell con Nodemon hecho con Willi (1:20 hs a 1:26 hs)

	Ejecutar Powershell como Administrador
	Ejecutar Policy para cambiar restringido a RemoteDesigned


Operadores (1:33:30 hs)

	Suma, resta,....
	modulo


PROMPT (1:40 hs)

	Es una funcion que permite que el usuario ingrese un valor


CONFIRM (1:54 hs)

	
************************************************************

Clase 16


Operadores Relacionales (36 min)

	>, <, ==, !=, >=, <=, ===

	=== (es identico en valor, tipo de dato, es un clon)



Condicionales (52 min)

	Son pequeñas estructuras de codigo que me dan la posibilidad de elegir cosas (if)

	NO ESTA CLASE: averiguar truthly / falsy 

	IF anidados (1:12:30 hs)

	IF anidados con operadores logicos (1:16 hs)

		&& || !


Uso de objeto window (1:54:30 hs)

	Imprimimos por consola el objeto window

	window es un objeto global, el objeto de la ventana, que tiene todos lo metodos, todos los datos del navegador, todos lo elementos html, todo css, todo js.

	window.location (traslada al usuario a algun otro lugar de mi aplicacion)


************************************************************

Clase 17

Examen Alumni (0 a 13 min)

Ramas en Git (18 min a )
		
	Una rama es una forma de tener diferentes versiones de mi proyecto guardados en un solo proyecto.

	git branch: me lista cuales son las ramas que tiene mi proyecto. Me muestra con un asterisco en que rama estoy parado.

	git branch nombreRama: crea una nueva rama.

	git checkout nombreRama: cambiar a otra rama.


	git merge nombreRamaOtraVersion: es una fusion, unir el proyecto a la rama principal.

		Yo necesito estar parado siempre en la rama a la que quiero aplicarle los cambios de otra rama.

	git push origin nombreRamaVersion: subo a git las otra rama.

	¿Se puede revertir la fusion?
		Si se puede, no dijo como.

	Conflictos al hacer fusion (1:18 hs)

	git remove || git reset || git revert

	git branch -D nombreRama: elimina una rama en la que no estoy parado.

	

	git log --oneline: me muestra los commits en una sola linea (resumida)


	git checkout hashCommit: vuelvo al estado anterior en ese hash commit (no crea rama, solo vuelvo para ver).

	git switch -c hashCommit: me lleva al estado de ese commit y me crea la rama.


Display (1:47:30 hs)

	Distribucion de elementos

	FLOAT



************************************************************

Clase 18


Nodemon es para backend, no funcionaria con el navegador.

Repaso Ramas (9 min a 15)



Eliminar una RAMA en el repositorio Remoto (16 min)
		
	Como hago para eliminar de Github la rama que ya habia eliminado de mi proyecto local.

		git push origin -d ramas



Display inline & float (36 min a 57 min)
	
	Display: inline & float: left (42 min)


Display FLEX (1:05 hs)

	display: flex;

	flex-direction: column;


flex-wrap (1:19 hs a 1:39 hs)

	Esto va con flex-direction: row;

	Flex por default esta en nowrap que no hace un salto de linea cuando llega al final.

	flex-wrap: wrap, habilita el salto de linea cuando termina la ventana.

	No hace falta usar flex-wrap:wrap con column porque por definicion ya tiene salto de linea column.

	Chrome devTools jugar con flex (1:30 hs)

		La herramienta del navegador me permite jugar con esas propiedades para ver como quedaria mi diseño con flex, para luego copiar a mi codigo en vscode las propiedades que me gustaron.

	
************************************************************

Clase 19


	Continuamos con Flex (40 min)

		Flex sobre ul 


	Tablas (1:32:30 hs)

		Una tabla es un pequeño cuadro para mostrar informacion, que puede venir de una base de datos.

		th: celdas titulos
		tr: fila 
		td: columna
	

	





************************************************************

Clase 20


Reset de CSS (12 min)

	Con el selector global * quito alguno de los estilos por default a todos los elementos .

	margin:0;
	padding: 0;
	box-sizing: border-box;

	Esto es lo minimo que podemos resetear.


CSS Normalize.css (25 min)


box-sizing: border-box  (26:30 min)

	Lo que hace es eliminar los padding - margin que vienen por default.

	Osea le estoy diciendo: Quiero que me midas desde el inicio de la caja hasta el final de la caja, no solo el contenido.



Bucles JS (35 min)

	un bucle es un ciclo que repite un estructura de codigo.


	
	Array / arreglo / vector (45 min)

			Estructura de un arreglo: let alumnos = [];

			Tiene un index o indice ue arranca desde cero.



	FOR (38 min)

		Funcion length (57 min)

	

	Funciones por defecto en Arreglos (1:34 hs)

	length: me da la longitud del array

	push: agregar elementos al final del Array




Objeto literal de JS (1:55:50 hs )

	Se accede por propiedad: nombreArreglo.propiedad




************************************************************

Clase 21


Explicacion Integrador 1 (5 min a 49 min)


JS no es un lenguaje orientado a objetos POO (1:00 hs)

	Breve explicacion de Clases en JS ()

		Se puede trabajar con clases en JS, pero generalmente NO SE HACE, porque si se quiere utilizar un lenguaje orientado a objetos
		para eso esta Java, PHP, C y TS por ejemplo. 

		


Objeto literal 

	Es la sintesis de un objeto de tipo clase.

	Es un objeto de forma sencilla que no dependa de una clase.



JSON - Objetos con notacion de JS (1:14 hs)

	Se utiliza para el paso de información de aplicacion a aplicacion.

	En JSON todo tiene que estar en tipo de dato string.



Intro a BOOTSTRAP (1:35 hs)

	Podemos utilizarlo via CDN y descargarlo en formato bundleado / minimizado y utilizarlo o descargar el codigo fuente para poder personalizarlo.

	Osea si queres personalizar, modificar algunos comportamientos por default hay que descargar el codigo fuente.

	


************************************************************

Clase 22


Descarga codigo bundleado Boostrap (26 min)

	Si descargo el bundleado de css y js de Bootstrap y tenemos que linkearlo desde el html, no tengo qu tener linkeado el CDN.

	Aca puedo modificar Bootstrap pero no engo acceso a todo.

	Para tener acceso a modificar todo el codigo fuente tengo que descargar el fuente que esta hecho con SASS.


Funciones ()

	Es una estructura de codigo que ejecuta una tarea especifica y puede ser reutilizada en diferentes partes del codigo.

	Funcion sin parametros y o argumentos (info que necesita la funcion para realizar la tarea)

	Funcion con parametros


Variables LOCALES (1:38 hs)

	Son las variables que viven dentro de una funcion y no pueden ser accedidos desde fuera de la funcion.


Variables GLOBALES (1:44:30 hs)

	Se recomienda crearlas al inicio de todo, porque son las que vamos a utilizar en cualquier parte de nuestro codigo.


QUE ES NAN ? (1:49:30 hs)

	Significa Not a Number, que significa que en algun lugar falto informacion o estamos queriendo un numero y me dieron un string.


QUE ES NULL ? (1:52 hs)

	Significa que antes habia algo pero ahora no hay nada.



ARROW FUNCTION - funcion flecha (1.58 hs)

	Se declaran como una CONST: Como las funciones son una estructura de codigo que no vamos a cambiar, entonces se declaran como una CONST.

	Salio en la version ECS 6.



************************************************************

Clase 23


	Watch incluido en Node (8 min)

		Nodemon ya viene incluido en Node desde la version 20, como "--watch"

		Tambien se puede ejecutar Typescript con Node.



	Repaso Variables Locales y Globales



	Funciones que retornan valores (37 min)



	Funciones CALLBACKS (59 min)

		Son funciones que reciben como parametro funciones.


	
	Eventos (1:01 hs)

		Utilizando un atributo de JS dentro de HTML (1:19:30 hs)

			El atributo onclick invoca a un elemento de javascript en nuestro a una funcion.


	Transformar un string a int (2:01 hs)

		con funcion parseInt()

		

************************************************************

Clase 25


	Funcion ANONIMA (51 min)

		Es una arrow Function sin nombre, se ejecuta automaticamente en el lugar en la que estan escritas.


	Validaciones en JS con IF(1:03 hs)



	Expresiones Regulares / REGEX (1:15 hs)

		Son algunas caracteristicas donde yo voy a trabajr con patrones.


	Que es el typeOf (1:22 hs)

		Puedo utilizarlo en condiciones: if (variable == typeOf Number)

	
	Objeto Math (1:47 hs)

		Sirve para calculos avanzados

		Es una clase estatica que se puede utilizar sin instanciarlo.

		Metodo random(): me da numeros random de entre en 0 y 1, si lo multiplico por 100 me danuemeros mayores

		Metodo round(): Me redondea al numero entero mas cercano, sacandome lo decimales.

		ejemplo de uso:

						Math.round(	Math.random() * 100)

						
									
************************************************************

Clase 26	


	Ejemplo de validación nativa de JS (20 min)

	
	DOM - getElementById (43 min) 

		Es la capacidad de Javascript de manipular todo lo que tiene el index.html

		con getElementById 

		Para que a traves de document tenga acceso a html TENGO QUE VINCULAR EL TAG SCRIPT EN la pagina html.

	
	AuthO (1:38 hs)

		Es un servicio de autenticacion pago

	
	Hacer Login con manipulacion de DOM (2:00 hs)



************************************************************

Clase 27


Atributo Method en Form (31 min)

	Me dice como voy a enviar los datos a traves del formulario.


Atributo action del Form (32 min)

	Es el archivo del Backend que va a recibir los datos del formulario para despues enviarlo a la base de datos.


Protocolo HTTP (38 min)

	Es un protocolo de transmision de informacion que tiene diferentes verbos osea diferentes formas.

	Una de las formas de la comunicacion de HTTP es el verbo GET.



Evento addeventlistener (1:18 hs)

	Usamos el evento e (1:25 hs)

		Accedemos a los valores de los inputs a traves del objeto global document
			email = document.getElementById("email").value

		Accedemos a los valores de los inputs a traves del evento "e"
			Usamos target.email.value 



Input checkbox valor value (1:40 hs)

	Se pueden seleccionar mas de uno a la ves.

	En los checkbox tengo que ponerle el atributo value para que no me devuelva solo on. Dato importante para la hora de obtener datos del input checkbox.

	Si quiero saber si lo marco o no lo marco entonces utilizo el atributo checked que me devuelve un booleano.
	
	
Input radio (2:00 hs)

	radiogroup, usamos el value



************************************************************

Clase 28


	Ejemplo de Modo Oscuro con JS (25 min a 48 min)


	Mostrar contraseña en input con JS (1:01 hs a 1:40 hs)

		Bajo el icono del ojito pero no pudo meterlo al input de contraseña, porque dijo que habia que hacerlo con css y estaba trabajando con HTML y JS.

	Input tipo hidden (1:40 hs a 1:51 hs)

			Sirve para indicar que cliente es por un id de cliente por ejemplo y luego conesto puedo obtener data como quien es el cliente, cuantos productos esta comprando algo que no se vea.


	Input tipo file (1:53 hs)

	
	Input tipo rango (1:58 hs)


	Input tipo date | datetime(2:02 hs)


	Objeto Date() (2:04 hs)

		let dia = new Date()


	textarea (2:14 hs)	

************************************************************

Clase 29


Configuracion de Entorno de Proyecto en NODE (16 min a 1:32 hs)

		Instalar Node
		
		npm init | npm init -y (32 min)

			Me sirve para inicializar un proyecto, para crear un ARCHIVO DE CONFIGURACION del proyecto.
				Me especifica:
								Cual va ser la version de este archivo
								Si tenes alguna palabra clave
								El archivo principal cual sera.
								La forma en que se va a ejecutar el archivo/aplicacion(scripts)

			Desde el archivo que me genera (package.json) yo puedo crear una aplicacion de React, Angular, View, de backend, puedo trabajar con Typescript con angular.

			
		Como cargar/importar un modulo nativo de Node (1:11 hs)

			const nombre = require('os');


		Como ejecuar un archivo desde scripts en package.json (1:23 hs)

			npm run iniciar


		
SASS (1:33 hs)

	npm install node-sass 

		¿por que no uso el flag "-g" de global?
			Por que no quiero que Node-sass este habilitado en todos los otros proyectos queno los estoy utilizando.

	No guardar la carpeta node_modules

	¿ Que es SASS o SCSS ?

		Es un preprocesador de CSS 

	¿Que hacen los scripts que paso Berni a poner en package.json? (1:56 hs)

		"build-css": "node-sass --include-path scss scss/index.scss css/index.css",
		"convertir": "nodemon -e scss -x \"npm run build-css\""

		Con el build llamamos a la libreria (node-sass) para que convierta de un tipo de archivo a otro tipo de archivo, "convertir" lo que hace es ejecutar Nodemon y ejecuta a la funcion Build.



************************************************************

Clase 30


	Repaso Node-Sass (0 a 40 min)

	
	¿Que es el package-lock.json? (43 min)
		Es un auditor del package.json

	SASS (53 min)

		Es un administrador de planillas css, la idea es que finalmente utilice una sola planilla index.css en donde se traspila todo lo que hacemos en SASS, de manera que solo voy a tocar el SASS y el index.css ya no lo toco.

		Puedo crear variables (54 min)

		Reinstalar Node Modules (1:10 hs)

			npm install : lo que hace es busca el package.json, lo lee e instala las dependencias necesarias.

		Anidamiento de estilos (1:19 hs)
			
		Mixin (1:31 hs)

			Son Bloques de codigo reutilizable, ejemplo:

				@mixin centrar{
					display: flex;
					justify-content: center;
					align-items: center;
				}

				Luego tengo que invocarlo con:

				div{
					@include centrar;
				}


		Separar por responsabilidades e IMPORTAR (1:40 hs a 1:48 hs)
			
			Poner _ a los archivos, por ejemplo:

						_variables.scss
						_mixins.scss
						_anidar.scss

			Porque es un archivo secundario que yo en algun momento voy a importarlo desde el index.scss.


************************************************************

Clase 31


	Nomenclatura BEM Bootstrap (31 min)

		Es un patron de diseño para la nomenclatura de las clases en CSS y la utiliza mucho Bootstrap.

		Me sirve para que no coincidan o no se dupliquen los nombres de clases en cuanto a estilos.

		BLOQUE ELEMENTO MODIFICADOR: .d-print-inline


	Media Querys (53 min a )

		Los breakpoints son los puntos de quiebre que tienen la mayoria de los dispositivos.


		Creo Puntos de Quiebre (1 hs)

			@content (1:12 hs)

				Significa que cualquier contenido que este dentro de ese mixin agregale esta caracteristica especifica.


		Herencia en SASS (1:33 hs)

			Usamos la palabra reservada % para crearlas

			Para usarla usamos @extend %align-center 

		

		Z-INDEX (1:45 hs)

		
					
		
************************************************************

Clase 33

	Backend

		Vamos a usar el backend para que le diga a mi html mostrate esto cuando el cliente haga esto, mostrate lo otro cuando el cliente haga esto.



	Seguimos con proyecto ejemplo con pagina Productos (10 min) 

	
	Intro a HTTP (21:30 min)

		Vamos a hacer un pequeño archivo que va administrar desde el backend el Front, que va administrar las respuestas que el cliente va a solicitar.


	Como funcionan las aplicaciones (45 min)

		Las aplicaciones funcionan con un software (servidor) que recibe peticiones y da la respuesta:

			const http = require('http');

			const servidor = http.createServer((peticion, respuesta) => {

			});

			Creamos un software que maneje la peticion y la respuesta y dentro esta todo el codigo que quiero que realize el backend de mi aplicacion. Este servidor es el que va administrar la peticion y la respuesta de mi servidor.

		Levantamos el Servidor | Ponemos en linea el servidor

			servidor.listen(3000, ()=>{
				console.log('Servidor en linea en el puerto 3000')
			});

			3000 es el nombre del puerto por el que yo quiero que se levante mi aplicacion. Es el canal por donde se va a ejecutar  la aplicacion.

			El arrow function es una funcion flecha que se ejecuta cuando se ejecuta el metodo listen.


	Que viene en la peticion ? (56 min)

		La peticion es lo que viene del lado del cliente, cuando el cliente busca educacion it, va un pedido| peticion al servidor, cuando lo encuentra nos devuelve el elemento y nos imprime en la pantalla con lo que necesitamos.

			console.log('URL: ', peticion.url)  -- veo la ruta que pide el cliente.

		De la peticion mas adelante vamos a tomar los datos que envian de los formularios, porque van a estar dentro de la peticion enviados.



	FS - Como hago para leer index.html desde mi aplicacion (1:46 hs)

		Es el sistema de archivos de Node



		Para leer un archivo html lo hago de la siguiente manera:

		const fs = require('fs');

			fs.readFile('.\index.html', 'utf8', (err, data) => {
				if (err) throw err;
				respuesta.end(data);
			});

		Se puede usar if o switch para los diferentes paths	

	

************************************************************

Clase 34


	Repaso SASS ( 5 min a 26 min )


	DOM Avanzado (59 min)

		
		Local Storage (1:18 hs)

			Es la memoria local del navegador, tiene una capacidad limitada, vamos a guardar pocas cosas aca, como por ejemplo el tema(light o dark) de la pagina y algunos otros datos no sensibles.

			Trabaja unicamente con datos STRING (por lo que si mando un bjeto literal JS voy a tener que convertirlo antes en string con JSON.stringify)

			Guardamos datos en el localStorage:

				localStorage.setItem("email", email);

			Obtener un valor del localStorage:

				localStorage.getItem("email")


			Cerrar Sesion (1:40 hs)

				Borrar la memoria local de localStorage:

					localStorage.clear(); 



************************************************************

Clase 35


	Gemini ( 14:30 min )

		Uso Gemini de Google para crear objetos productos en JSON


	Uso el archivo data.js como una base de datos local



	cargarProductos.js ( 25 min a )



	Objeto Event - e (1:15 hs)



	Funcion anonima y arrow (1:24 hs)

		Las funciones anonimas y las arrow function se ejecutan automaticamente cuando le damos click al evento, NO LA INVOCAMOS PARA QUE SE EJECUTEN. SIEMPRE SE VAN A AUTOEJECUTAR CUANDO LO ESCRIBAMOS EN CUALQUIER PARTE, ya tienen una funcion de return por default asi que va a tirar el resultado cuando se ejecuten.



	Repaso addEventlistener (1:25 hs)

		Le agrego un evento a ese elemento.

	
	Limpiar campos Formulario desde JS ( 1:29 hs )

		1 forma -> Creo referencia al formulario por id desde js y luego uso la funcion predefinida reset()

		2 forma -> Creo funcion en la que a cada input.value le asigne un string vacio.



Continuamos DOM Avanzado 

	Nos metemos un poc mas en Administracion, manejo, gestion avanzada de JS:

		Obtenemos datos desde el archito HTML

		Creamos elementos

		Insertar elementos

		Darle estilos a los elementos

			Agregarle una clase

	Guardamos el aray de productos en el localStorage (1:31 hs)

		localStorage.setItem("productos", JSON.stringify(misProductos));

		JSON.stringify me vuelve a tipo texto el objeto	


	
	Creamos una funcion para cargar la tabla con los productos (1:45 hs)

		


************************************************************

Clase 36


	Agregarle clases a elementos desde JS (14:30 min)


	No puede agregar desde el boton de Listar Productos	(1:40 hs)

		Solucion: 

			Para no llamar a la funcion que imprime los productos (cargarTabla) en tabla en el evento del boton "Cargar" podemos pasarla al evento de Listar Productos y tenemos que tomar los datos desde el localStorage.


************************************************************

Clase 37


	Otra estrategia con button type submit (7 min)

		Creamos un nueov button con type submit y le ponemos un id al formulario.
		Capturamos le formulario en JS:

			let formulario = document.getElementById("miForm")

			formulario.addEventlistener('submit', (e) => {})

		En el HTML tengo que tener el boton con type submit:

			<button type="submit"> Otro Login <button>

		El submit sirve para envio de datos. (LO VAMOS A UTILIZAR EN BACKEND)

		En el ejercicio anterior le pusimos al boton con evento click para que haga lo que queriamos, PERO SI QUIERO ENVIAR DATOS DESDE EL FORMULARIO AL BACKEND LUEGO VOY A TENER QUE UTILIZAR SUBMIT. El evento lo tiene el formulario, osea que cuando envie los datos efectue la accion.



	Creando una pagina desde JS (37 min)

		let titulo = document.createElement("h1")

		titulo.innerHTML = "Ecommerce de Tecnologia"

		document.body.appendChild(titulo)


	appendChild (57 min)

		Inserta el elemento dentro del contenedor padre.


	Creamos titulo de pagina desde JS (50 min a 1:17 hs)

	Creamos la barra de Navegacion (1:20 hs a 1:47 hs)



************************************************************

Clase 38	

	Correccion TP 07 (15 min a FIN)


************************************************************

Clase 39

Explicacion TP 08 (2 min a 15 min)

Actividad con Kahoot (25 min a 45 min)

REACT (1:50 hs a 1:51:30 hs)

	REACT YA ESTA CON ES6 POR DEFAULT.

	React es un SPA, es una aplicacion de una sola pagina. Donde todo lo que vamos a hacer es escribir codigo JS y automaticamente React lo va ir subiendo a medida que lo vamos necesitando.

	¿Que tipo de paginas van con React?

		- Aquellas paginas que tienen miles de visitas porque es mucho mas rapido react.


CREATE-REACT-APP (49 min a )

	Es una libreria que nos permite crear una aplicacion/template de React.

	Es una libreria que ya no se usa tal cual, porque se crearon nuevas formas para crear proyectos en React que luego veremos en el boot.

		Instalacion:

			* De forma Local y global con: npm install -g create-react-app

			* Instalar sin tener la libreria de forma local, otra diferencia es que npx (npx create-react-app my-app) me va a traer las dependendias que yo necesite con la ultima version.

	npm start (1:06:30 hs)

		Me arranca la aplicacion, me genera un pequeño template, un pequeño modelo estructurado que esta listo para usarse.


	Arquitectura de Aplicacion de React (1:30 hs)

		Los directorios nuevos que aparecen son Public y Source


			Public:

				manifest.json: es la configuracion de los iconos o de los logos (no nos sirve ahora)

				robots.txt: es una pequeña configuracion que si quiero que algunos robots de google lo permitan o no.

				index.html


			Source (src):

				Todo el codigo fuente que importa para que funcione esta pagina esta en la carpetita src.

				App.test.js (no me sirve ahora)

				setupTests.js (no me sirve ahora)

				reportWebVitals.js son reportes que hace Google para unas caracteristicas de mobile por ejemplo(no me sirve ahora)

				Index.js es el ARCHIVO PRINCIPAL

				App.js es otro ARCHIVO IMPORTANTE y aqui vemos el componente principal.



************************************************************

Clase 40			


		Repaso React clase anterior (3 min a 12 min)

			Todo en React son componentes (paginas, archivos), en vez de lanzar paginas vamos a lanzar componentes, un boton puede ser un componente. Por eso es una SPA.

			ya no vamos a crear paginas como productos.html sino que vamos a crear componentes y los vamos a ir renderizando y pasandoselas a React para que lo MUESTRE AL CLIENTE EN UNA SOLA PAGINA.

			El trabajo con React me ayuda a distribuir mejor las cosas y para no repetir codigo.

			No vamos a navegar entre paginas, vamos a navegar entre componentes.


		package.json (13 min a )

			en scripts:

				start: es el modo dev de nuestro proyecto

				build: construye la aplicacion

				test: es si queremos correr algun test

				eject: elimina, saca todo el funcionamiento nativo de React, lo pone en cero, a no se que queramos manipular los archivos de node modules porque si lo hacemos la pagina public se convierte en una pagina nativa, anulamos el trabajo que tiene por default React. 


			en SRC (16 min):


				Todos los archivos que creamos tienen que estar dentro de src, porque REACT TIENE UN FUNCIONAMIENTO ESTRUCTURADO DENTRO DE LOS NODE MODULES QUE TODO LO QUE NEECSITA RENDERIZAR Y TODO EL CODIGO FUENTE ESTA EN EL DIRECTORIO SRC. Si yo quiero cambiar esa arquitectura por default ahi si necesito ejecutar el script eject.

			
			React  no esta escrito en JS, sino en JSX que es una mezcla de JS con HTML


			LA APLICACION PRINCIPAL ES INDEX.JS (49:30 min)


			ReactDOM (50:30 min)

				Es el que memoriza la ultima aplicacion y lo guarda en el virtual DOM.

				El navegador cada vez que percibe un evento el navegador recarga la pagina, vuelve a pintar la pagina.

			Las librerias React y ReactDOM que se eimportan en index.js son el corazon de mi aplicacion.



			Sintaxis para para importar una imagen en React:

				import logo from './logo.svg';


			El componente principal es APP


	Componente de TIPO FUNCION (1:19 hs a )

	DETALLES A TENER EN CUENTA PARA TRABAJAR CON REACT:
			
		Es un componente funcional porque el componente esta hecho con una funcion.

		Tiene un metodo return y retorna UN SOLO ELEMENTO de JSX.

		En JSX no utilizamos class sino className.

		En los atributos de las etiquetas HTML para esilos se usa camelCase.

		Estoy obligado a cerrar todas de HTML en React (1:57 hs)


	Usamos Bootstrap en aplicacion React (1:33 hs)

		Los links de css y js de Bootstrap van en el index.html.

		Solo tenemos que recordar que tenemos que utilizar camelCase.


	Como CREAR COMPONENTES NUEVOS (1:40 hs a )

		Por convencion mi funcion tiene que tener el mismo nombre que mi componente.


	Creo COMPONENTE NAVEGACION (1:44 hs)

		Traigo componente navbar de Bootstrap.

		React solo devuelve un solo elemento por componente, ejemplo de mal uso:

		return(
			<nav>.. </nav>

			<main>..</main>
		)

		SI QUIERO DEVOLVER DOS COSAS, necesito usar una herramienta que me da React para que disimule que hay 2 elementos: React.Fragment, que es un componente padre que engloba como componentes hijos a un monton de cosas:

		return(
			<React.Fragment>

				<nav>.. </nav>

				<main>..</main>

				<footer>..</footer>

			<React.Fragment>
		)

	
		Necesitamos exportar el componente: "export default navegacion" 


		Como llamamos al componente desde App.js (2:05 hs)

			1º Tengo que importar el componente.
			2º Lo llamo como una etiqueta HTML: <Navegacion /> (tengo que dejar ese espacio para que se diferencie de los otros elementos como los div's).

			3º Agrego el React.Fragment.

		

************************************************************

Clase 41


	Pequeño repaso de los visto en la clase anterior (5 min a 20 min )

		Los componentes son simplemente funciones.

		El componente debe devolver un solo elemento JSX.

			Si tengo dos elementos y los quiero devolver en el return entonces tengo que usar React.Fragment, que tambien se puede usar con su atajo:

				<>
				....
				..
				</>

		
	React Router DOM ( 21 min a )

		Es una libreria que necesitamos para enrutar nuestras paginas.

		Pagina con documentacion: reactrouter.com


		Instalacion ()

			npm i react-router-dom


		Crear un Enrutador basico con React Router DOM (1 hs)

			Vamos a necesitar estos 3 componentes:

				BrowserRouter

				Router

				Route

		
		BrowserRouter (1:02 hs)

			Es el administrador principal del Enrutador, sin esto no funciona nada.

				1° Importamos el Administrador del Router en el archivo index.js

						import { BrowserRouter } from "react-router-dom";

				2° Envolvemos (wrapear) toda la aplicacion con el elemento BrowserRouter

						<BrowserRouter>
							App
						</BrowserRouter>

			En la pagina oficial estan los ejemplos de codigo, porque mas alla de los materiales en alumni, quizas yo quiero llevar eso a otro lugar, se puede desarmar todo esto y armar de otra manera, ponerlo todo en la barra de navegacion.



		Routes - Configurar las rutas (1:30 hs a  )

			La rutas las configuramos donde nosotros queramos.

			Es una configuracion que no va aparecer dentro del navegador porque son solo las rutas.

				1°	Importamos y creamos el contenedor padre Routes donde van a trabajar las rutas

						import { Routes } from 'react-router-dom'

						<Routes>
						....
						</Routes>

				2°  Importamos route y configuramos las rutas y los componentes que queremos subir y bajar segun el diseño de la aplicacion

						import { Routes, Route } from 'react-router-dom'

						<Routes>
							<Route path='/' element={<App/>}/>
						</Routes>
				
						Lo que estoy haciendo en ese Route es decirle al navegador que cuando el cliente vaya a / bajame todo lo que tengas y subime la App.

						import Login from './Pages/Login';

						<Routes>
							<Route path='/' element={<App/>}/>
							<Route path='/login' element={<Login />}/>
						</Routes>

				
				3°  Debemos decirle a la aplicacion de react donde esta este path, donde esta el login y donde esta nosotros (donde estan esos paths)

				Tengo que importar el elemento de react-router-dom, Link:

					import { Link } from 'react-router-dom'

					Utilizamos Link en vez del anclas de html(a) y saco el atributo href:

						<Link to='/' >APP</Link>



************************************************************

Clase 42 - CLase de EMPLEABILIDAD



************************************************************

Clase 43


	Integrador 2 - explicacion ( 2 min a 15 min)


	Aplicacion React en proyecto de alumno ( 42 min a )

		Agregamos Bootstrap 

		Elegimos la estructtura que vamos a manejar(50 min):

			- Folder componentes, folder css y folder Pages

			- Folder Home, Contacto y componentes

		Como trabajamos con las imagenes en React (1:06:30 hs a ) 

			No trabajo igual a cuando usaba js y html nativos tengo que tratarlo como un objeto:

			1º tengo que importar el objeto

				import logo from '../image/logo.png'

			2º la variable logo la pongo en src del img (cada imagen tiene que tener su propia variable, ahora hacemos asi pero luego con base de datos lo vamos a hacer automatico)

				<img src={logo} ... />

		
		Agregamos los estilos css (1:12:30 hs)

			ponemos todos lo estilos en app.css aunque luego se puede discriminar por componentes.



		
		Pasamos el Footer a React (1:26 hs a )

			No tuvimos que importar los estilos en el conponente Footer porque ya los esta leyendo desde el componente de Navegacion. Pero es mejor si no importo el mismo css en dos lugares distintos y lo hago solo en el App.js que es el componente principal, porque estan centralizados los estilos.


		
		Pagina Error (1:50 hs)

			La imagen no hizo falta importarla y usarla como un objeto porque como esta leyendo un archivo fuera del componente ahi si lo puede leer, porque el componente se carga/monta lee el archivo y lo puede mostrar.




************************************************************

Clase 44	


	Login (4 min a 17 min)

		

	useNavigate (24 min a )

		Me redirige a la pagina que yo le diga.


		1º Importamos el componente:

			import { useNavigate } from "react-router-dom";

		2º Declarar una constante que utilice la funcion:

			const navigate = useNavigate();

		3° Hacemos el redireccionamiento a la pagina que deseo:

			navigate('/admin')


	Creo componente Admin (32 min a 34 min)


	Creo componente Ecommerce (43 min )


	Uso de LocalStorage en React ( 58 min )


	React Bootstrap ( 1:02 hs )

		La diferencia con el Boosttrap comun es que React bootstrap ya esta preparado con el className y todas las caracteristicas que nosotros tenemos que agregarle a un componente de React trabajando con Bootstrap sin tener que hacerlo manualmente.

		



	Traigo carrusel de React Bootstrap (1:11 hs)


	Variables en React (46 min)

		En JS nativo manejabamos las variables de la siguiente manera:

			let email = document.getElementById('email')

		Pero en React no nos manejamos asi, se TRABAJA CON HOOKS
	

	HOOKS - useState ( 1:51 hs )

		El useState es una memoria de trabajo que mientras este activado el componente me va a guardar el dato despues ya no me lo va a guardar, para eso despues vamos a utilizar el useContext para que algunas variables las guarde y las maneje de forma global mientras quye el cliente va cambiando de componente. (clase 45 - 52 min)

		GUARDA LAS VARIABLES MIENTRAS ESTA MONTADO EL COMPONENTE EN EL NAVEGADOR.

		Manejamos los estados con React.

		Con useState yo creo la variable y luego le puedo cambiar los valores con la funcion que viene por defecto.

		1º Tenemos que importar el useState, no tenemos que instalarlo porque ya viene con React:

			import { useState } from 'react'

		2º Manejamos los estados creando un arreglo de variables:

			Creo los estados o variables:

				const [] = useState('')

				const [email] = useState('') <- esto seria igual en JS nativo a: let email = ''

			Cuando quiero cambiar los valores de esa variable, para cambiar los valores en el estado/variables tengo una funcion que viene con el estado: 

				const [email, setEmail] = useState('')


			¿COMO CAPTURAMOS EL ELEMENTO HTML DESDE REACT? -> Lo vamos a capturar a traves del evento(e).

	

************************************************************

Clase 45


	Dudas alumnos clase anterior (6 min a 25 min)	


	En JS nativo yo obtenia los datos a traves del DOM, en React 
	

	Repaso uso de useState para crear variables ( 26 min a 33 min)


	useContext ( 34 min )

		Es otro hook que utilizamos par que en una memoria global guardemos algunas variables que no se pierdan.



	Obtener datos en React sin DOM en Login ( 39 min a 1:21 hs )

		Como ya no podemos usar el .value en Dom como veniamos haciendo en JS nativo, utilizamos el event para obtener el value: event.target.value

		1°  A los inputs le agregamos el atributo value={email} para que React lo reconozca.

			value={email}

		2° Cuando cambien el dato del input, cuando alguien vaya escribiendo los datos dentro del input, ejecutame una funcion donde le vas a tomar el event para luego enviarle value a setEmail(la unica responsable de darle valor a la variable email):

			onChange={(event) => setEmail(event.target.value)} 


		Y usando useState para crear variables y almacenar ahi los valores de los campos (email, password)

	
	QUE ES UN HOOK PERSONALIZADO ? (1:30 hs)

		Es una funcion de JS que realiza una tarea especifica.



	COMO AGREGAR PRODUCTOS AL CARRITO ( 1:37 hs a  1:44 hs && )

		Usamos useState 

		Construi un objeto con los datos del producto

		Usamos localStorage para enviar el objeto producto 



	Carrito ( 1:45 hs )


		Agrego link bootstrap icono

		Agrego link en Navegacion con icono

		AgreGo en rutas


		Creo componente Carrito ( 1:49:30 hs )

			Armo estructura tml de Carrito

			Agrego boton con evento buscarCompras

			Agregamos useState para guardar los productos del localStorage en variable misCompras e imprimirla en el h2

		
		Usamos useEffect ( 2:03 hs )

			Es una funcion que HACE UNA LLAMADA PREVIA A LOCAL STORAGE, SE FIJA SI HAY ALGO Y YA LO GUARDA EN LA VARIABLES misCompras Y ESO ES LO QUE YO QUIERO MOSTRAR, ENTONCES ya tiene listo los datos para mostrarme cuando el componente de cargue, POQUE DE LO CONTRARIO SE VA CARGAR EL COMPONENTE Y NO VA PODER ACTUALIZAR LOS DATOS DE LA VARIABLE EN EL MISMO MOMENTO SINO ESTA USANDO USE EFFECT.




	

************************************************************

Clase 46


	Repaso clase anterior ( 2 min a 5 min )

	Repaso Concepto de Objeto en JS ( 6 min a )

	Diferencias entre Objeto Literal JS y Objeto JSON (9 min a )

		EL navegador no puede contener un objeto literal JS en el local Storage, necesita que se a un dato de tipo string, por eso necesitamos guardarlo de tipo JSON (objeto de tipo de dato string)

		Para eso tenemos el metodo JSON.stringify para converitir de objeto literal JS a string, para la inversa tenemos JSON.parse 


	Cuando nosotros completamos nuestros datos en un registro ¿Como viajan nuestros desde el formulario? -> Viajan como JSON y se insertan estos tipos de datos en una base de datos, luego ¿como lo convertimos a un objeto de JS para usarlo? utilizamos el JSON.parse y sino utilizamos MIDDLEWARES que lo veremos mas adelante.

	
	Lo que el HOOK me genera son variables dinamicas que yo puedo usar/mostrar mientras el componente este montado.

		Yo puedo usar una variable normal como veniamos usando en JS nativo: let carrito = 'Enargey gel $2500' y luego en el componente llamarlo: {carrito} y me lo va imprimir pero luego no voy a poder cambiarlo. Por eso necesito useState.


	UseEffect ( 50 min a 54 min)

		Tiene dos argumentos, en el primero recibe un callback donde le decimos lo que queremos que haga cuando se ejecute (que es lo que va hacer cuando se ejecuta antes de que el componente se monte en el navegador), en el segundo parametro es un arreglo para que este pendiente de algun cambio en el carrito (quiero que estes atento a algo). 


	CARD Bootstrap para renderizar productos en CARRITO ( 59 min a 1:15 hs )

		El Style no puede ir en TIPO DE DATO TEXTUAL entonces tengo que ponerle dos llaves: style={{width: 18px}}



	Sesion Storage ( 1:16 hs )

	Es la memoria de la sesion donde nosotros tambien podemos guardar datos pero cuando se cierra la navegacion desaparece este dato, por eso es una sesion.

	
	Limpiar Local Storage ( 1:23 hs a 1:29 hs )

		con removeItem('producto') -> Elimino un solo producto

		.clear() -> Elimina todo


	Uso datos de Sesion Storage ( 1:37 hs a )

		Obtengo el user de sesion Storage para mostrarlo en un h1 en carrito

	
	Uso MAP para mostrar todas las CARDS ( 1:54:30 hs a  hs)

		No se puede usar un bucle for en React

		No puedo iterar poque necesito objetos para colocar en el componente.

			Necesito que carrito sea un array

			Tengo que usar MAP ( es otra variable de los bucles de iteracion )

		PERO NO TERMINO DE APLICAR MAP


	
	************************************************************

Clase 47


BACKEND


	Nosotros habiamos trabajado con modulos nativos de Node como el modulo HTTP para crear un servidor nativo pero actualmente para poder construir un BACKEND vamos atrabajar con otra libreria muy importante que trbaaja con el core de Node y para nosotros es mas facil y mas rapido, la libreria se llama EXPRESS, esta es la libreria que vamos a utiliza rpara poder trabajar con nuestras aplicaciones de backend.


	EXPRESS ( 15 min a )

		Es un framework/ herramienta / tecnologia que trabaja con el codigo nativo de Node el modulo http pero manera mas sencilla para nosotros.

		Express lo que hace es administrar el Servidor.
		
		Repaso Creacion servidor nativo con modulo http ( 15 min a 21 min)

		Inicializamos la configuracion del proyecto con "npm init" o "npm init -y"

		Instalo nodemon como dependencia Dev: npm i nodemon -D (osea en modo LOCAL)

		Instalamos la herramienta Express ( 25 min )

			No podemos instalarlo de forma global, porque cuando subimos el servidor a un hosting que estemos pagando, necesitamos que en el servidor que trabaja con node JS lo instale para que funcione nuestra aplicacion.

			Genero script/comando dev en package.json: "nodemon src/index.js" para luego poder usar "npm run dev" y poder trabajar en mi compu con la aplicacion permanentemente abierta. En Servidor ya no hara falta este comando dev sino el "start": "node src/index.js" porque el servidor ya tiene una herramienta como el nodemon que mantiene la aplicacion abierta permanentemente.

			Instalo con: "npm install express --save" el save lo que hace es dejar asentado en el package.json que express es una dependencia importante que luego el hosting debe instalar. No tiene que esta como Dev dependencies. 
			Si yo quiero instalar la ultima version esntonces yo necesito ejecutar: "npm install express@latest"

			Por ahora vamos a estar utilizando ES5 (Ecma Script 5) que no usa import como veniamos trabajando con React(ES6)

			Creamos la referencia(importamos) a Express para poder utilizarla:

				const express = require('express')

			Creo otra variable donde ejecuto sus funcionalidades (Creamos una instancia de Express):

				const app = express()


		CREO RUTA en EXPRESS (1:07 hs)

			app.get('/',)

			El primer parametro es un ruta (endpoint) y el segundo parametro es un callback que se va ejecutar automaticamente cuando el cliente solicite esa ruta.


			Esa funcion maneja dos parametros tambien que vana ser funciones, peticion y respuesta o request y response:

				app.get(t'/', function (peticion, respuesta ){
					respuesta.end('Bienvenido a mi primer servidor con express')
				})

			
		Asignamos un puerto a la aplicaicion (1:16 hs)

			const PORT = 9000


		Levantar el servidor y ponerlo en escucha (1:16:40 hs)

			app.listen(PORT, () =>{
				console.log('Servidor express escuchando en el puerto ${PORT}')
			})	

		
		Ejecutar mi aplicacion Express (1:18 hs)

			npm run dev


	Asi quedo mi codigo:

		const express = require('express')

		const app = express();

		app.get('/', function(peticion, respuesta) {
			respuesta.end('Bienvenido a mi primer servidor con Express')
		});

		const PORT = 9000;

		app.listen(PORT, () => {
			console.log('Servidor express escuchando en el puerto ${PORT}')
		});

	
	Teoria EVENT LOOP (1:35 hs a 1:45 hs)

		Como trbaja con las peticiones realizadas por el cliente, a traves del nucelo Event Loop.

	
	Envio datos en mi response ( 1:46 hs a  )

		res.json({
			nombre: 'Juan',
			apellido: 'Perez',
			edad: 25
		})


	¿Cuantas respuestas puedo enviar al cliente? (1:57 hs)

		Puedo enviar solo una response por metodo al cliente, en todo caso si necesito otra respuesta necesitaria crear otra ruta,

	



	************************************************************

Clase 48


	Repaso clase anterior (2:30 min a 59 min)


	POSTMAN (8 min a 12 min && 1:16 hs)

		Es una herramienta profesional para realizar peticiones y realizar pruebas y realizar solicitudes HTTP.

		Sirve tambien porque como ya no creamos un front con formularios que me hagan peticiones, postman simula ser un frontend.

		Si queremos enviar datos a mi backend no vamos a esar creando un formulario cada vez que quiero enviar datos, para eso se uiliza POSTMAN.

		
		¿COMO SE UTILIZA?

		1° Necesito saber que tipo de verbo HTTP voy a estar utilizando.

		2° Puedo crear colecciones para guardar mis rutas, creamos uno para express

		


	Una vez que terminamos de configurar el package.json que es la forma en que el servidor va levantar esta aplicacion, osea son las indicaciones que le doy al servidor para que prepare el entorno donde se va ejecutar mi aplicacion.


	PORT en BACKEND (55 min )

	Para desarrollo loval en backend se suele usar el PORT 9000 o 8080


	Los Procesos de NODE (1:04:30 hs a 1:14 hs)

		process es el bucle que Node esta ejecutando por debajo de mi aplicacion, para procesar todas las funciones en el to do y para responder a mi peticion segun lo que el cliente pida.

		con peticion.header vimos lo que viene en la peticion, con process.env estamos viendo lo que tenemos dentro de nuestro equipo con Node funcionando.


	Metodo POST (1:55 hs a )

		Significa que mi servidor va a recibir datos, el POST es cuando la request/peticion que trae informacion (por ejemplo email y contraseña)

			app.post('/login', (req, res) => {

				let email;
				let password;


			})

			El argumento que recibe informacion desde el front es el request, en "request.body" viene la informacion que trae el post.

			app.post('/login', (req, res) => {

				let email = req.body.email ;
				let password = req.body.password;

			})


		Luego verificamos el funcionamiento del post en POSTMAN:

			En Body tenemos que elegir como va ir la informacion: lo enviamos como tipo formulario codificado (x-www-form-urlencoded) Y NO SE PUDO TIRO Error

			Tuvimo que enviar datos de tipo JSON (raw) Y TAMPOCO FUNCIONO PORQUE SEGUN BERNI NECESITAMOS CONFIGURAR MIDDLEWARES




	************************************************************

Clase 49


	problema con merge de Berni (0 a 16 min)


	Repaso clase anterior ( 17 min a 22 min)


	Importaciones para que librerias manejen ciertas caracteristicas ( 22:30 min a )

		Importar el puerto

			Variables de Entorno ( 24 min )

				Las variables de entorno se manejan con una libreria especifica que es DOTENV 

				
		Libreria DOTENV o Variables de Entorno (43 min)

			Sirve para que no queden a la vista variables de entorno o variables (contraseñas sensibles) importantes que yo no necesito que ni el administrador de los servidores lo vea. 	

			Sirve para ocultar datos importantes que no se tienen que compartir.

			FUNCION en NODE: dotenv.config() oculta los datos en el codigo e introduce las variables que hemos escrito en el archivo .env dentro de los procesos de Node, cosa que la aplicacion vaya a buscar alos procesos la variable que necesita.




		USO LIBRERIA DOTENV (46 min)

			1° Instalo libreria en terminal: npm i dotenv || npm install dotenv --save

			2° Impotamos dotenv en app.js para utilizar las variables de entorno: const dotenv = require('dotenv')

			3° Pido o ejecuto la configuracion de dotenv: dotenv.config() 

				estos dos son iguales:

					const dotenv = require('dotenv')
					dotenv.config() 

					require.('doenv').config()

			4° Crear el archivo de variables de entorno:

				En el root/raiz del proyecto creo un archivo .env

				Dentro de .env creo las variables que quiero ocultar, generalmente las variables estan todas en mayusculas: 

							PORT_SERVER=3000
							PASSWORD_EMAIL=MI VARIABLE DE Google
							DATABASE_URL=MI VARIABLE DE MONGODB

				
			5° Ver valores de variables de entorno:

				console.log(process.env.PORT_SERVER)

	
	¿Por que utilizamos PROCESS.ENV.PORT? (1:20 hs)

		Vamos a GLITCH, que es un servidor de prueba, para probar el deply del backend.

		Ahora vamos a probar con GLITCH-HELLO-NODE

		AGREGAMOS LAS VARIABLES DE ENTORNO EN GLITCH.

		Tener cuidado con las versiones de Node y las dependencias, porque por ejemplo Berni instalo Express 5.0.1 y esta solo trabaja con versiones de Node de 18 para arriba, pero Glitch acepta Node 14.8 por lo que tuve que bajar la version de Express a una que funcione con Node 14.8



		Luego puedo probar con postman con el path del sevidor Glitch


	Descargar algo de POSTMAN (1:51 hs )

		Quiero darle una ruta para que descargue un archivo:

			app.get('/descargar', (req, res) =>{
				res.download('./archivo.txt')
			})

		Para que funcione tenes que poner este get despues de la ruta de error en el codigo.

		  

	************************************************************

Clase 50

	SUSPENDIDA




	************************************************************

Clase 51

		Comentarios sobre los TP's Integradores (0 min a 9:30 min)


		FEEDBACK clase ANTERIOR (9:30 min a 12 min)


		MIDDLEWARES (22 min a 1:31 hs)

			EL BACKEND(NUESTRA APLICACION, LA LOGICA) NO ESTA ENTIENDO LOS DATOS QUE ESTA ENVIANDO EL FRONT PORQUE LE FALTA UN MIDDLEWARE A NUESTRO BACKEND PARA QUE LE INTERPRETE EL DATO QUE VIENE TIPO JSON. NO PODEMOS USAR JSON.PARSE PORQUE ESTO NO VIENE DESDE UN LOCAL STORAGE VIENE DE UN FORMULARIO O DESDE CUALQUIER OTRO LUGAR. ENTONCES NECESITAMOS UN MIDDLEWARE(FUNCION) QUE RECIBA LOS DATOS DE TIPO JSON Y LOS TRANSFORME EN UN OBJETO DE JS PARA QUE NUESTRA APLICACION ENTIENDA Y LO PUEDA TRABAJAR. 

			NO PUEDO USAR JSON.PARSE O STRINGIFY PORQUE ESO ES PARA EL FRONT Y NOSOTROS ESTAMOS TRABAJANDO CON BACKEND Y NECESITA OTRAS HERRAMIENTAS.

			Cuando quiero realizar un POST envio un json pero como no es una notacion de lenguaje de programacion mi aplicacion no lo entiende:

				{
					"email": "prueba@gmail.com",
					"password": "1234"
				}

			Entonces para no tener que utilizar el pasaje de Objeto Json a objeto literal JS yo puedo utilizar MIDDLEWARES. 

			Un MIDDLEWARE es una pequeña funcion que esta entre la PETICION del cliente y la recepcion de los datos del Backend(RESPUESTA). Una funcion que recibe la peticion del cliente, realiza un proceso(traducir json a obj literal JS, verificar si el cliente esta autenticado, etc) y despues la envia a la ruta que fuese.




			Creamos un MIDDLEWARE personalizado (28 min)

				En Express ya hay middlewares predefinidos

				function middleware(req, res) {
					console.log('Soy un middleware');
				}



			Como utilizo/configuro/aplico el MIDDLEWARE (30:30 min)

				app.use(middleware)



			Los middlewares necesitan que nosotros le avisemos que una vez que realice la tarea deje ir a la peticion a la ruta donde esta intentando matchear. Lo hacemos agregando al middleware otro parametro que se llama next (un callback):

			function middleware(req, res, next) {

					console.log('Soy un middleware');

					next();
				}



			Usamos Middleware JSON de Express (54 min)

				Para la recepcion de DATOS DE OTRAS APLICACIONES.

				Se ejecuta en TODAS LAS RUTAS.

				Me sirve para convertir datos de tipo JSON en objetos literales:

					express.json()
					express.urlencoded() (decodificame lo que viene dentro de la url)


			RECORDAR ESTO: UNA PETICION TIENE UNA SOLA RESPUESTA, NO PUEDO TENER DOS RES.SEND(...) (1:04 HS)

			ESTE MIDDLEWARE SIRVE PARA ENVIOS DE DATOS CRUDOS (RAW) JSON DESDE POSTMAN.



			Usamos Middleware URLENCODED de Express para FORMULARIOS (1:16 hs)

				Para la recepcion de DATOS DE FORMULARIOS

				Se ejecuta en TODAS LAS RUTAS.

				Para entender datos que vengan a traves de URLENCODED a traves de los formularios.

					app.use(express.urlencoded({extended: true}));




		Motores de Plantillas ( 1:33 hs a  )

		Son los primeros pasos de React, Angular, etc. Son parecidos a los componentes pero en lenguaje nativo, osea crear un prqueño componente pero con codigo nativo con html, css y js.

		No es una Aplicacion REST (estan separadas la logica del backen y el frontend, como React y Node) sino SSR (cuando el FRONT esta INTEGRADO al BACKEND)

		Cuando utilizamos motores de plantilla paara el backend se llama RENDERIZACION DEL LADO DEL SERVIDOR (SSR)  


			Instalamos libreria Handlebars hbs (1:37 hs)

				npm i hbs

			
				1° Importamos las funcionalidades en una variable:
				
						const hbs = require('hbs');

				2° La configuramos:

						app.set('view engine','hbs');

					Configuramos la carpeta de las vistas, donde van a estar las vistas, los archivos de handlebars:
					Van a estar en el Directorio principal (_dirname) en la carpeta views:

						app.set('viwes', _dirname + '/views');

					Adentro de la carpeta views tiene que haber un archivo importante que se tiene que llamar layout.hbs

					El LAYOUT ES EL DISEÑO PRINCIPAL DE TODO.


					¿Como le muestro el hbs al cliente desde mi aplicacion? (1:49 hs)

						Tengo que crear un ruta:

							app.get('/hbs', (req, res) => {
								res.render('index')
							})

					Como funciona el motor de plantillas con HBS (1:53 hs)

						Dentro de las carpeta views, la libreria de hbs busca un archivo principal y este tiene que llamarse layout.hbs 

						Los motores de plantillas trabajan como React, hay un componente principal que es la app y dentro de app yo tengo que llamar a todos los otros componentes para que lo puedan renderizar, LO MISMO PASA CON LOS MOTORES DE PLANTILLAS, ESTA LAYOUT (EL DISEÑO PRINCIPAL DE HBS) PERO NO ME MUESTRA INDEX PORQUE NO LO HE LLAMADO DESDE LAYOUT.



						CONFIGURO AL LAYOUT COMO EL CUERPO O EL BODY PRINCIPAL DE LA APLICACION:
						
							 {{{ body }}}	

							todos los otros archivos de handlebars (hbs) que yo renderize: 

								app.get('/hbs', (req, res) =>{
									res.render('index')
								})

							los va a traer y los va a pegar en {{{ body }}} y saca el anterior hbs, similar a como funciona React montando y desmontando componentes.



	************************************************************

Clase 52


	Lectura Desafio 09 (0 min a 8:30 min)


	Configuracion Proyecto serverCompleto (11 min a )
		
		Creo proyecto	

			npm init -y


		Instalo librerias importantes:
		
			npm i express dotenv hbs path morgan

			path y morgan son las librerias nuevas
		

		Agrego script:

			"start": "node server.js" ,

			"dev": "nodemon server.js"



		Iniciamos a ver PATRON: VISTA - CONTROLADOR

			SERVER.JS es el archivo principal de nuestra aplicacion y vamos a conectarnos a la base de datos y levantar el servidor.

			APP.JS es otro archivo importante donde se realizaran configuraciones.


		ES MEJOR DIVIDIR (MODULARIZAR) NUESTRO CODIGO EN ARCHIVOS QUE TENGAN CIERTA RESPONSABILIDAD PARA QUE NOSOTROS DESPUES PODAMOS REALIZAR EL MANTENIMIENTO DE LA APLICACION DE UNA FORMA MAS RAPIDA.


		Importamos los modulos necesarios en app.js

			const express = ..
			const hbs = require('hbs');
			const bodyParser..
			const path ..
			const morgan..

		
		Que hace path:

			Es un modulo que lo que hace es dirigirme, ayudarme a encontrar rutas en algunas caracteristicas especificas. Es una libreria de rutas, que nos ayuda a rutear archivos, direcciones que nosostros por ahi no podemos encontrarlas de forma manual. 


		Que hace morgan:

			Lo utilizamos en modo dev: app.use(morgan('dev'))

			Cuando me hagan una solicitud, me va a tirar data como estan matcheando tal ruta y la respuesta que le lanze fue 200 fue 400, en tal dia, tal hora.. etc.

			Me sirve para tener mas informacion de lo que pasa en el servidor. 

			El objetivo es recibir informacion una vez que esta trabajando nuestro servidor para si hay algun problema me tire mas informacion.

		
		Configuracion de Archivo .env (36 min)

				Creo archivo .env y le seteo PORT=3000

		Configuracion Handlebars - hbs (37 min)

				app.set("view engine", "hbs")

				app.set("views, path.join(_dirname, "views"))   -> es mas formal y elegante usar la libreria path.join para buscar rutas a como lo hicimos en el proyecto anterior de manera manual.


		Definimos las rutas (40 min)

		Exportamos app


		Como no levanto el servidor en app, entonces muevo dotenv a server.js


		Defino el modo en que uso morgan (50 min)

			combined

			tiny	 

		

		Creo el layout en views (1 hs)

			Necesitamos crear dentro de la carpeta views un archivo que es el modelo, el layout, es el archivo ppal parecido a app.js de react (usa la misma estrategia de React).

			Tenemos que poner un layout para que pueda "pegar los componentes" (no son componentes)


			Partials (1:07 hs)

				Son pequeñas plantillas que las voy a necesitar siempre y cuando las necesito las llamo.

				Creo dentro del directorio views una carpeta partials y ahi creo navegacion.hbs o footer.hbs.


				¿Como llamo a una plantilla de diseño (partials) dentro del layout?

						Hay que configurar al servidor para que vaya a buscar los partials en la carpeta, par alo cual en app.js agregamos:

							hbs.registerPartials(path.join(_dirname, "views/partials"))	

						{{> navegacion }}


		TRES FORMAS DE HACER FRONTEND (1:18 hs)

			1- Codigo NATIVO html, css y js

			2- React que es una libreria o un framework como angular (esto es para hacer una api rest, separado el front del back)

			3- Motores de plantillas (hbs, ejs y pug) 

				Es un modelo de arquitectura SSR (server side rendering), porque es el servidor que renderiza el front

				
		Middleware de manejo de ERRORES ( 1:31 hs a 1:53 hs)

			El manejo de errores de server.js me muestra el error a mi en la terminal. El de bhs es para el usuario.

			Hay un error 404 de pagina no encontrada con la ruta "/*"

			Hay un error de servidor 500 forzado con la ruta "/error"

	
	FINALMENTE: Hicimos una aplicacion nueva con codigo mucho mas limpio. Importamos las librerias que necistamos, instanciamos la aplicacion express, configuramos todos los middlewares, configuracion de mi motor de plantillas que voy a utilizar, definimos las rutas



	Mezclamos HBS con HTML ( 1:56 hs a  )

		Cuando quiero enviar archivos html utilizo:

			app.get("/html", (req, res) => {
				res.sendFile(_dirname, "public", "index.html")
			})

		Creo carpeta public y adentro archivo index.html

		
		REACT LO UTILIZAS PARA PROYECTOS MAS GRANDES (SALE MAS CARO TENER QUE PAGAR 2 SERVIDORES)

		SSR SALE MAS BARATO PORQUE PAGAS EL SERVIDOR DEL BACKEND Y LUEGO EN EL MISMO BACKEND RENDERIZAS EL FRONT CON HBS O HTML.




	************************************************************

Clase 53

	Feedback clase anterior ( 2 min a 6:30 min )


	Administrar las RUTAS ( 7 min a )

		Vamos a sacar las rutas de app.js para un mejor delegamiento de responsabilidades.

		Para administrar las rutas, Express tiene una aplicacion que se llama express.Router

		Puedo tener todas las rutas en un solo middleware.


		1° Creamos una variable router donde ejecutamos el enrutador de express:

			const router = express.Router()


		2° Utilizamos la variable con el verbo que nosotros queremos (get, post,..)

		3° Exportamos

		4° Importamos y la utilizamos como un middleware (como la trabajamos dentro de la aplicacion)


		Directorio para Rutas ( 18 min )

			Todos los pasos anteriores hay que aplicarlos en el directorio router en el archivo routerHome.js:

			Una vez qcreado el archivo con las rutas la tengo que exportar y luego en el archivo principal app.js la tengo que importar.

			Luego en app.js lo utilizo como un middleware

			En routerHome.js van a estar las rutas que estaban en app.js


		Middleware para uso de ARCHIVOS ESTATICOS ( 36 min )

			app.use(express.static(path.join(_dirname, "/public")))

			Si justo tengo dos rutas que coinciden tanto en el front de HBSA como en el de html me va a tomar el de html.


			¿ POR QUE NECESITAMOS EL MIDDLEWARE DE LA LECTURA DE ARCHIVOS ESTATICOS?

				Por que en Public estan nuestros archivos css y en las vistas necesitamos leer archivos de css, PERO al colocar ese middleware en Public encuentra el archivo index.html y automaticamente lo va a renderizar y va obviar la vista con hbs:


					router.get("/", (req, res) => {
						res.render("index")
					})

					router.get("/", (req, res) => {
						res.sendFile("index.html")
					})


	
		Creo otras rutas ( 54 min )

		Para la ruta /user tengo los endpoints "/" y "/login" tengo que recordar siempre poner antes /user:

			/user/

			/user/login


		
		MATCHEAR las Rutas ( 1:08 hs )




	ESTAMOS TRABAJANDO CON UNA PLICACION SERVER SIDE RENDERING, ESTAMOS HACIENDO PETICIONES (REQUESTS) Y QUE ME ESTAN RESPONDIENDO CON RECURSOS, EN ESTE CASO ME RESPONDEN CON MOTOR DE PLANTILLAS DE ME MUESTRA EL USUARIO EL HOME.


	Base de Datos (1:30 hs)

	
		MongoDB

		Instalando herramientas:


		Productos -> Comunity Edition -> Download Comunity

		Productos -> MongoDB Compass GUI


		En proyecto creamos un directorio nuevo Conexion y ahi adentro creamos archivo conexion.js


		Dentro de Disco C -> Creamos un diretorio que se llama "data" para que cuando se inicialize mongodb en nuestra compu va a guardar todos los datos ahi para TRABAJAR EN MODO LOCAL. Dentro de data creamos otro directorio llamado "db".



		MongoDB Compass (1:45 hs)

		Para trabajar los archivos de mongoDB que se guardan en la carpeta db.

		Ya me viene creada una base de datos test.

		Como cambiamos de db en mongosh:

			use nombreBD

		Como crear una coleccion ?

			db.createCollection("nombreColeccion")

		Como insertamos datos en esa coleccion ?

			db.users.insertOne({nombre:"Pepe", email: "pepe@gmail.com"})

			Eso que parece un obeto en realidad es un DOCUMENTO que es la informacion que estoy guardando en la coleccion.

		Ver lista de usuarios:

			db.users.find()

			

	************************************************************

Clase 54

			SUSPENDIDA



	************************************************************

Clase 55


	Feedback clase anterior (0 min a 19 min)


		Un documento puede tener 16 Megas .

		MongoDb y SQL son las dos BD mas utilizados dentro del mundo de desarrollo

		Estas BD se puede utilizar en Amazon Web Services, en Azure, en Google Cloud, en railways, en cualquier aplicacion que podamos utilizar de servidor y subir nuestra aplicacion. 



	Conexion a Base de Datos (20 min)

		Necesito un ODM, una libreria que es un administrador de objetos de documentos, que me ayuda a hacer las inserciones de datos , los updates de una forma mas sencilla.


	Mongoose (32 min)

		Instalo Mongoose:

			npm i mongoose

		Creo una variable de entorno con la url para la conexion a mi base:

			MONGO_LOCAL=mongodb://localhost:27017/fullstack


		Configuracion archivo de conexion.js (40 min) 


		Explicacion Funcion ASYNC ( 43 min a 51 min)

			Es una funcion con la que le estamos diciendo a Node JS quiero que me ejecutes esta funcion pero ejecutala cuando te responda la base de datos por ejemplo o ejecutala cuando se cumpla un determinado periodo de tiempo o ejecutala cuando puedas.


	Conexion a la Base de Datos ( 55 min a )

	Vimos 3 formas de conectarnos a la base de datos la 3° es la mejor opcion:

		1) Conexion Directa:

			En esta conexion no exportamos nada a server.js

			mongoose.connect('mongodb://localhost:27017/fullstack')


		2) Conexion con variables de entorno:

			const dotenv = require('dotenv')
			dotenv.config()

			const MONGO_LOCAL = process.env.MONGO_LOCAL
			const MONGO_ATLAS = process.env.MONGO_ATLAS

			const conexion = async (MONGO_LOCAL) => {
				try{
					await mongoose.connect(MONGO_LOCAL);
					console.log('Conexion a la Base de Datos exitosa')
				} catch (error){
					console.log('Error en la conexion a la Base de Datos:', error);
				}		
			}

			module.exports =  conexion;			

		
		3) Conexion a la Base de datos con URL de parametro:
		
			const mongoose = require('mongoose')

			const conexion = async (URL) => {
				try{
					await mongoose.connect(URL);
					console.log('Conexion a la Base de Datos exitosa')
				} catch (error){
					console.log('Error en la conexion a la Base de Datos:', error);
				}		
			}

			module.exports =  conexion;


	Hay mas opciones para crear conexiones en la documentacion oficial de mongoose.


	REQUEST CON DATOS TOPO POST:	

		Metodo POST en Formulario ( 1:24 hs )

			Va cumplir el mismo rol que el POSTMAN para enviar datos, con una ruta especificamente señalada en el atributo action para dejar los datos que se van cargando en el formulario:

				<form method="post" action="/user/register">		
				</form>


		Diferentes VERBOS con el mismo ENDPOINT ( 1:26 hs )

			router.get("/register", ...)

			router.post("/register", ...)


		
		Poner KEY en formulario POST para URLENCODED (1:35 hs)

			EL value va a ser lo que los usuarios completen en los inputs.

	
	AHORA NOS FALTA GUARDAR ESTOS DATOS EN LA BASE DE DATOS.

	El password tenemos que encriptarlo.



	ESQUEMA DE LA BASE DE DATOS ( 1:49 hs )

		Para EVITAR ingresar cualquier tipo de dato en mi coleccion, osea por ejemplo: yo estoy trabajando con datos de usuarios y me ingresan un documente relacionado con datos de paises.

		Para esto genero un archivo que se llama Schema con mongoose, que me define la estructura de un documento de mi coleccion. 


	Genero el schema de mongoose en un archivo userModel.js dentro de un folder Models:

		const mongoose =  require('mongoose')
		const { Schema } = mongoose

		const userSchema = new Schema({
			nombre: {
				type: String,
				required: true
			},
			email: String,
			password: String,
			date: {
				type: Date,
				default: new Date()
			},
		})

		module.exports = mongoose.model('User', userSchema)

	Luego en el enrutador (userRouter.js) importo el schema del usuario:

		const User = require('../models/userModel')

		const persona = {
			nombre, 
			email,
			password 	
		}

		const newUser = new User(persona)

		newUser.save() -> con este save estaria haciendo en mongoose un insertOne en la base de datos.

		y con esto ya me guarda desde el front datos en la base de datos local.


	************************************************************

Clase 56

	Feedback clase anterior ( 0 min a 16 min )

	
	Hacemos Login ( 36 min a )

		Queremos loguearlos

		Porque funciona con algunos correos electronicos y con otros no (1 hs)

			Me marca leyenda "Usuario encontrado" con algunos y con otros no y eso pasa porque LO ESTAMOS HACIENDO SINCRONICO y para que no se rompa una 	aplicacion en determinado momento tenemos que utilizar ASYNC (le digo a Node JS cuando te puedas conectar a la base de datos y cuando puedas verificar que todo esta bien RECIEN AHI RESPONDEME PARA QUE YO PUEDA ENVIAR EL RESPONSE, ENTONCES AHI FALLA PORQUE NUESTRA FUNCION ES SINCRONICA, HACE UNA CONSULTA RAPIDA PERO NO LE DA EL TIEMPO A NODE JS DE HACER UN FIND POR EL CORREO.

			Para que funcione bien tenemos que hacer al post de login una FUNCION ASINCRONA:

				router.post('/login', async (req, res) => {
					const { email, password } = req.body

					const usuarioExiste = await User.findOne({ email })
					....
					..
				}) 	

			Entonces le estoy diciendo tambien con el await que cuando se conecte con la base de datos CUANDO RECIBA LA RESPUESTA guardame eso en esa variable e imprimimelo y ahi tendria que tener la respuesta correcta.


		ENCRIPTAR password en el registro ( 1:20 hs a )

			Instalo Libreria bcrypt para encriptar contraseñas

				npm i bcrypt

			Pasos de uso:

				1º Importamos la libreria:

					const bcrypt = require('bcrypt')


		
			Uso TRY & CATCH ( 1:38 hs a 1:45 hs)

				El try and catch es una sintaxis PARA CAPTURAR ERRORES para que no se rompa nuestro hilo de Node, osea que crashee la aplicacion. Entonces con el try y catch le estamos diciendo a Node que haga unas tareas complicadas y que intente hacerlo y si no sale que un error PERO QUE NO SE ROMPA y lo que nosotros le estamos mandando al cliente para que no se rompa la aplicacion ES UNA PAGINA DE ERROR.

				Nos metimos aca porque la libreria bcrypt recomienda trabajar con async await para poder encriptar la contraseña. 

				EL try & catch y el async await esta pendiente hasta que se conecta o no se conecta a la base de datos, DE ESA MANERA NOSOTROS EVITAMOS QUE LA APLICACION CRASHIE O SE ROMPA.


			Si el usuario no existe al momento de registrarse, encriptamos la contraseña:

				1º Creamos la salt para encriptar la contraseña:

					const salt = bcrypt.genSatSync(10)

				
				2º Mezclamos la salt con el password del cliente (encriptamos la contraseña)

					La encriptacion de la contraseña del cliente mezclada con la salt de bcrypt

					persona.password = bcrypt.hashSync(password, salt)
				


				Algunas empresas deciden tercerizar el tema de la autenticacion, por lo que envian los datos del usuario a Auth0



	************************************************************

Clase 57	

	Feedback Clase anterior ( 0 min a 12 min )



	Validacion de Datos en Backend ( 14 min a 1:29 hs)

		Necesitamos validar la informacion que nos ingresan a la base de datos porque sino la base se llena de daos basura.

		Verficamos que los campos no esten vacios

				Primero podemos poner un validador en el frontend, el atributo required de los campos (FRONTEND)

				Segundo podemos poner un if validador para asegurar que los campos no esten vacios (BACKEND)

				Tercero verificamos los ipos de datos de forma manual (BACKEND)

			Estos son solo 3 casos de validacion hay muchos mas, actualmente para evitar tener que hacer todas las validaciones posibles manualmente, existen librerias disponibles en Node JS que cumplen estas tareas, express-validator.

			Estas librerias me ayudan a validar informacion que viene a mi backend.

			Es un middleware por lo que tiene que estar entre el endpoint y la funcion que responde a la peticion del cliente (request):

				router.post("/register", middleware , async (req, res) => {...)

			1- Instalo express-validator:

					npm i express-validator

			2- Importamos body de express-validator:

					const { body, validationResult } = require('express-validator')

			3- Agregamos las validaciones en el middleware:

					body('nombre')
					.isLength({´min: 3, max:20}).withMessage('El nombre debe tener entre 3 y 20 caracteres')
					.isEmpty().withMessage('El nombre es obligatorio')
					.isString().withMessage('El nombre debe ser de tipo texto')
					.trim(), <- este es para sacarme los espacios en blanco
					body('email')
					.isLength({´min: 8}).withMessage('El nombre debe tener como minimo 8 caracteres')
					.notEmpty().withMessage('El nombre es obligatorio')
					.isString().withMessage('El password debe ser de tipo texto')
					trim(), 
	
		Vamos a ver validaciones que usan if's todavi porque node ya tiene mas de diez años y en codigo antiguo quedo asi.


		validationResult controla que todo lo que tiene que ver con body funciona:

					const {nombre, email, password} = req.body;

					const errores = validationResult(req)


	Realizamos bucle para recorrer array de errores e imprimir el msg del error que necesitamos mostrar al cliente ( 1:18 hs )

		No puedo usar el bucle For comun.

		Para hacer el bucle For dentro de un motor de plantilla:

			<ol>
				{{ #each error }}
				<li>{{this}}</li>
				{{/each}}
			</ol>

			y necesito tambien pasarle el array de msg de errores, esto lo hago adentro del try:

				error: errores.array().map(error => error.msg)



	Envio de mail al usuario al registrarse ( 1:31 hs a  )

		Usamos Nodemailer para poder enviar correos electronicos de una aplicacion a otra.

		Instalo:

			npm i Nodemailer

		
		Para no sobrecargar nuestro controlador de registro podemos utilizar una carpeta helpers donde podamos ir tirando todas estas funciones que tengan caracteristicas especificas y exportarlo para modularizar nuestro codigo.

		Pasos de Uso:

		1º - Importamos nodemailer: const nodemailer = require('nodemailer')

		2º - Creamos un transportador

				Es la empresa, la aplicacion, configuracion del operador de correo electronico de mi ecommerce que va estar enviando el correo electronico.

		


			1º - Gestionar tu cuenta de Google
			2º - Seguridad
			3º - Verificacion en 2 pasos tiene que estar activado
			4° - Contraseña de aplicaciones
			5° - Creo la contraseña de aplicacion y me lo guardo en algun archivo txt
			6º - Creamos las Variables de entorno en el .env:

						 GOOGLE_PASSWORD=
						 GOOGLE_EMAIL=emanuel.some@educacionit.com

			7º - Creo el archivo enviarMails.js dentro del folder helpers y ahi copio el codigo que me da nodemailer en la documentacion para configurar el envio de mails.

			8º - Hago los cambios en el codigo de nodemailer (ver codigo berni)

			9º -  Importamos el archivo en el controlador userRouter.js:

					const enviarMail = require('../helpers/enviarMails')

			10º - Antes o despues de que el cliente guarde los datos enviamos el mail:

					await newUser.save()

					enviarMail(email, nombre)	


	************************************************************

Clase 58

	Feedback clase anterior (3 min a 16 min)


	Repaso Frontend con React para luego hacer la Api REST (18 min a )


		En la API REST el BACK y el FRONT se comunican exclusivamente mediante datos tipo JSON


		1° - Instalamos librerias importantes:

				npm i axios bottstrap react-bootstrap react-router-dom

		2° - limpiamos codigo del proyecto React

		3° - Vamos armando los componente con React-Bootstrap

				De esta manera ya usamos plantillas y hacemos mas rapido

				Traemos barra de NAVEGACION

		4° - Recordamos el routeo 

			Como creamos las rutas en React:

				1)

				en index.js hago impot { BrowserRouter } from 'react-router-dom'

				encierro a App.js en BrowserRouter

				2)

				en App.js hago: import { Routes, Route } from 'react-router-dom' y creo las rutas y pongo los href

		5° - Creamos componente Formulario y componentes mas pequeños

				Traemos button para formulario de react-bootstrap

				Agregamos componente de imagen


		6° - Importamos a useState ( 1:43 hs a  )

				Esto lo hacemos para mantener el nombre, el email y el password porque no tenemos manejo del DOM entonces tenemos que desestructurar el useState.

				Como tomamos los datos del formulario ? ( 1:48:45 hs)

					Capturamos el event dentro del input que en este componente seria Form.Control y agreamos el evento que dispara la funcion que cambia la variable en useState:

							value={nombre}
							onChange={(e) => setNombre(e.target.value)}


	BACKEND (2:00 hs)

		7 - Axios

				Es una libreria especializada en los metodos HTTP

				Es el que hace la magia para que viajen los datos del formulario al backend como json

				Importamos Axios en componente Formulario.js: import axios from 'axios'

				function Formulario(){
					...
					..
					.

					const handleSubmit = (e) => {
						e.preventDefault()

						try{
							axios.post(''.{
								nombre,
								email,
								password
							})

							handleReset(e)

							console.log('Datos enviados correctamente')

						} catch (error){
							console.log('Error al enviar datos' + error)
						}
					} 
				}

		PARA QUE RECIBA DATOS NUESTRO BACKEND en userRouter.js creamos una ruta:

			UTILIZO EL SERVER,la userRouter del proyecto: 21-serverCompleto

			router.post('/creado', (req,res) => {
				const { nombre, email, password } = req.body

				console.log(nombre,email, password)

				res.json({
					data: 'Usuario creado con exito'
				})
			})

		En Formulario.js agrego await a la accion post y async al nombre de la funcion handleSubmit

				await axios.post('http://localhost:9000/user/creado')



		extension para autocompletado de codigo: git copilot, blackboxai



	************************************************************

Clase 59

	EL OBJETIVO ES UNIR EL FRONT Y BACKEND Y QUE ENVIE LOS DATOS Y QUE LOS PODAMOS VER EN UNA BASE DE DATOS.


		
	El TP Integrador 3 tiene que tener un Front un Back y una conexion a base de datos que pueda hacer el CRUD/ABM (14 min a 15:40 min)



	El BACK puede estar en GLITCH y el FRONT puede estar en otro servidor como RENDER.


	Libreria CONCURRETLY ( 5:30 min )

		ESTO ES MODO DEV

		Sirve para trabajar con BACK y FRONT en un mismo directorio mientras estamos desarrollando, osea que esto es modo dev.

		Me sirve para ejecutar dos aplicaciones a la vez


		En el package.json afuera de las aplicaciones back y front:

			En scripts va:

						"dev": "consurrently --kill-others \"cd back & npm run dev \" \"cd front & npm start\""


			SIEMPRE HAY QUE PONER EN EL PRIMER COMANDO QUE ESTAMOS EJECUTANDO EL BACKEND, PORQUE CAPAZ NECESITA CONECTARSE A LA BASE DE DATOS Y EL FRONT POR AHI NECESITA CONSUMIR ESOS DATOS PARA MOSTRARNOS ALGO DENTRO DE ALGUN COMPONENTE.




	Limpio el codigo de index.js que me traje de app.js del proyecto 21-serverCompleto en el back (30 min)

		VOY A SINTETIZAR EN UN SOLO ARCHIVO(index.js) MI BACKEND

			Elimino:

					hbs, routerHome y Product, app.use de static, app.use('/') y ('/product'), ya no necesito los codigos de manejos de errores, configuracion de motor de vistas

			No exportamos el modulo:

					voy a server.js del proyecto 21-serverCompleto y me copio el codigo para index.js:

						Hago las modificaciones que aparecen en el codigo de Berni

			Creo variable de entorno .env


		En el backend tenemos que traer del proyecto 21-serverCompleto conexion.js, userModel.js y userRouter.js (44 min)

		Limpiamos userRouter.js en mi proyecto (48 min)

			Borro la importacionnde enviarMails

			Borro todas las renderizaciones de HBS que ya no utilizamos

			Borro el post.('/creado')

			Borro enviarMail


		Copio toda la carpeta de src del proyecto appCompleta (55 min)

			en el directorio Front tengo que instalar las siguientes librerias: 
			
								npm i axios bootstrap react-bootstrap react-router-dom



	Problema con CORS ( 1:02 hs a 1:12 hs )

		Axios no pudo enviar los datos porque hay algo de las politicas de CORS que estan impidiendo que mi aplicacion de React se conecte con mi Backend, LA SOLUCION A ESTO ES INSTALARLE CORS para actualizar.

		Cors es una pequeña dependencia que autoriza a recibir solicitudes HTTP a ciertas paginas, lo usamos como un middleware.

			npm i cors (esto en el BACK)

			En el index.js del Back lo uso como un middleware:

						const cors = require('cors')
						app.use(cors())

		Y CON ESTO CONECTAMOS NUESTRA APLICACION DE REACT CON NUESTRA APLICACION DE BACKEND. LO UNICO QUE LOS UNE SON LOS METODOS HTTP(POST, GET,..) A TRAVES DE DATOS DE TIPO JSON 



	SweetAlert ( 1:23 hs a )

		Es una libreria que le muestra al usuario cuando tiene un error.

		Lo voy a usar para mostrar form diseñados para los errores que salten en mi aplicacion.

			Instalacion en el Front:

				npm install sweetalert2


			Importamos en Formulario.js:

				importa Swal from 'sweetalert2'

				




	
	















	

